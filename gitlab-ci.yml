# .gitlab-ci.yml
#
# AppWorld 2026 – Module 2/3 Lab
# Security-as-Code gate using security-controls.yaml
#
# Stages:
#   1) policy_gate: enforce baseline security controls + conditional requirements
#   2) test: app tests
#   3) build: build & push image
#   4) deploy: terraform apply (vK8s + LB + security toggles)
#
# Files:
#   - security-controls.yaml (required)
#   - openapi/openapi.json (required if api_discovery.enabled: true)
#   - app/templates/login.html + app/templates/contact.html (required if bot_advanced.enabled: true)
#
# Outputs:
#   - features.env (dotenv artifact) => ENABLE_WAF, ENABLE_API_DISCOVERY, ENABLE_BOT_ADVANCED, ENABLE_RATE_LIMITING

stages:
  - policy_gate
  - test
  - build
  - deploy

workflow:
  rules:
    - if: $CI_PIPELINE_SOURCE == "push"
    - if: $CI_PIPELINE_SOURCE == "web"
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"

default:
  interruptible: true

# ---------------------------
# Stage 1 – POLICY GATE
# ---------------------------
policy_gate:
  stage: policy_gate
  # Intentionally no image: this job is designed to run on a SHELL runner
  # (If you later move to Docker runner, set image: alpine + install yq/python accordingly.)
  tags: ["shell"]
  rules:
    - when: always
  script:
    - python3 scripts/validate_security_controls.py
    - echo "Policy gate passed. Exported features.env:"
    - cat features.env
  artifacts:
    reports:
      dotenv: features.env
    expire_in: 2 hours

# ---------------------------
# Stage 2 – TEST
# ---------------------------
test:
  stage: test
  # If you use Docker executor runners, set an image.
  # If you use Shell runner, remove image and ensure python/pytest exist on the runner VM.
  image: python:3.11-slim
  needs: ["policy_gate"]
  rules:
    - when: on_success
  script:
    - python -V
    - pip install -r requirements.txt
    - pytest -q

# ---------------------------
# Stage 3 – BUILD & PUSH IMAGE (ACR, amd64, short-sha tag)
# Image format:
#   <login-server>/appworld/<student-id>/<app>:${CI_COMMIT_SHORT_SHA}
# Where:
#   <student-id> == $F5XC_NAMESPACE
#   <app>        == $APP_NAME (default: f5-ai-generated-app)
# ---------------------------
build_and_push:
  stage: build
  image: docker:27
  services:
    - docker:27-dind
  needs: ["policy_gate", "test"]
  variables:
    DOCKER_TLS_CERTDIR: ""
    DOCKER_BUILDKIT: "1"
  rules:
    - when: on_success

  before_script:
    - set -euo pipefail

    # --- Required variables ---
    - test -n "${ACR_LOGIN_SERVER:?ACR_LOGIN_SERVER is required}"
    - test -n "${ACR_USERNAME:?ACR_USERNAME is required}"
    - test -n "${ACR_PASSWORD:?ACR_PASSWORD is required}"
    - test -n "${F5XC_NAMESPACE:?F5XC_NAMESPACE (student-id) is required}"
    - test -n "${CI_COMMIT_SHORT_SHA:?CI_COMMIT_SHORT_SHA is required}"

    # Optional app name
    - APP_NAME="${APP_NAME:-f5-ai-generated-app}"

    # --- Login to ACR ---
    - docker login "$ACR_LOGIN_SERVER" -u "$ACR_USERNAME" -p "$ACR_PASSWORD"

    # --- Enable buildx for explicit amd64 builds ---
    - docker buildx create --use --name appworld-builder || docker buildx use appworld-builder

  script:
    - set -euo pipefail

    # Construct image ref
    - IMAGE_REF="${ACR_LOGIN_SERVER}/appworld/${F5XC_NAMESPACE}/${APP_NAME}:${CI_COMMIT_SHORT_SHA}"
    - echo "Building and pushing: ${IMAGE_REF}"

    # Build + push (amd64)
    - docker buildx build --platform linux/amd64 -t "$IMAGE_REF" --push .

    # Export for deploy stage (Terraform reads IMAGE_REF from dotenv)
    - echo "IMAGE_REF=$IMAGE_REF" > build.env
    - cat build.env

  artifacts:
    reports:
      dotenv: build.env
    expire_in: 2 hours


# ---------------------------
# Stage 4 – DEPLOY (Terraform)
# ---------------------------
deploy_f5xc:
  stage: deploy
  image: hashicorp/terraform:1.6
  needs: ["policy_gate", "build_and_push"]
  rules:
    # Lab default: deploy only from default branch
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: on_success
    - when: never

  before_script:
    - set -euo pipefail
    - cd terraform

    # --- Required vars (fail fast with clear messages) ---
    - test -n "${F5XC_NAMESPACE:?F5XC_NAMESPACE is required}"
    - test -n "${F5XC_API_TOKEN:?F5XC_API_TOKEN is required}"
    - test -n "${IMAGE_REF:?IMAGE_REF is required (from build.env artifact)}"

    # Optional feature flags should still exist if your TF expects them
    - test -n "${ENABLE_WAF:?ENABLE_WAF is required}"
    - test -n "${ENABLE_API_DISCOVERY:?ENABLE_API_DISCOVERY is required}"
    - test -n "${ENABLE_BOT_ADVANCED:?ENABLE_BOT_ADVANCED is required}"
    - test -n "${ENABLE_RATE_LIMITING:?ENABLE_RATE_LIMITING is required}"

    terraform init -upgrade

  script:
    - set -euo pipefail
    - terraform apply -auto-approve \
        -var "namespace=${F5XC_NAMESPACE}" \
        -var "f5xc_api_token=${F5XC_API_TOKEN}" \
        -var "image=${IMAGE_REF}" \
        -var "enable_waf=${ENABLE_WAF}" \
        -var "enable_api_discovery=${ENABLE_API_DISCOVERY}" \
        -var "enable_bot_advanced=${ENABLE_BOT_ADVANCED}" \
        -var "enable_rate_limiting=${ENABLE_RATE_LIMITING}" \
        -var "openapi_spec_path=../openapi/openapi.json"

  artifacts:
    when: always
    paths:
      - terraform/terraform.tfstate
      - terraform/terraform.tfstate.backup
    expire_in: 2 hours
